# Completions
autoload -U compinit; compinit
# Allow to select in a menu
zstyle ':completion:*' menu select
# Case insensitive, partial words
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'

setopt MENU_COMPLETE        # Automatically highlight first element of completion menu
setopt AUTO_LIST            # Automatically list choices on ambiguous completion.
setopt COMPLETE_IN_WORD     # Complete from both ends of a word.

# без PROMPT_SUBST
# понимает только свои %-последовательности — %n, %~, %F{red}, %m и т.п.;
# строка вида $(prompt_prefix) воспринимается просто как буквальный текст и печатается как $(prompt_prefix).
setopt PROMPT_SUBST

# command history
HISTFILE="$HOME/.zsh_history"
HISTSIZE=10000        # сколько команд держать в памяти
SAVEHIST=10000        # сколько команд писать в файл

setopt APPEND_HISTORY        # не перезаписывать файл, а дописывать
setopt INC_APPEND_HISTORY    # писать в файл по мере ввода, а не только при выходе
setopt SHARE_HISTORY         # шарить историю между сессиями

setopt HIST_IGNORE_DUPS      # не добавлять подряд одинаковые команды
setopt HIST_IGNORE_ALL_DUPS  # убирать более старые дубли
setopt HIST_REDUCE_BLANKS    # чистить лишние пробелы

# colors in completion
[[ -z "$LS_COLORS" ]] || zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"

# use emacs key bindings
bindkey -e

# User configuration

# homebrew fix on apple silicon mac
eval "$(/opt/homebrew/bin/brew shellenv)"
# for rosetta compatible run
# eval "$(/usr/local/bin/brew shellenv)"

# node version manager
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash/zsh completion

# rust
. "$HOME/.cargo/env"

# fzf keybindings
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# various setups
for file in ~/.config/zsh/*; do
  source "$file"
done

# no ctrl + d
set -o ignoreeof

# unicode in alacritty https://github.com/tmux/tmux/issues/328
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

# vim
export MANPAGER="nvim +Man!" # man in vim
export EDITOR="nvim"
export VISUAL="nvim"
alias vim="nvim"

export GIT_PS1_SHOWDIRTYSTATE=1
export GIT_PS1_SHOWSTASHSTATE=1
export GIT_PS1_SHOWUNTRACKEDFILES=1

# PATH
export PATH="$HOME/.local/bin:$PATH"

# colors in prompt
autoload -U colors && colors

# prompt config
#  - e0b6  - e0d6  - e0ba
#  - e0bc  - e0a0
# %f - сброс foreground, %F{color} - цвет foreground
# %K - сброс background, %K{color} - цвет background
PROMPT='$(prompt_prefix)%F{yellow}%F{white}%K{yellow}%n%K{cyan}%F{yellow}%K{cyan}%F{white}%c%f%k$(check_git_repo)'$'\n''$ '
RPROMPT=''

prompt_prefix() {
  local parts=()

  local print_hostname='yes'
  if [[ -n "$SSH_CONNECTION" ]]; then
    parts+=('%F{red}%K{red}%F{white} %m %k%F{red}%f')
  fi

  if [[ -n "$LF_LEVEL" ]]; then
    parts+=('%F{red}%K{red}%F{white} [LF] %k%F{red}%f')
  fi

  # если parts пустой — ничего не выводим
  (( ${#parts[@]} )) || return

  echo -n "${(j: :)parts} "
}

function check_git_repo() {
  if [ -z $(git rev-parse --git-dir 2> /dev/null) ]; then
    echo "%f%k%F{cyan}%f%k"
  else
    echo "%F{cyan}%K{red}%F{white}%K{red} $(__git_ps1 ' %s ')%f%k%F{red}%f%k"
  fi
}

lfcd() {
  local oldpwd="$PWD"
  local tmp
  tmp="$(mktemp)"

  command lf -command "set user_OLDPWD '$oldpwd'" -last-dir-path="$tmp" "$@"

  if [ -f "$tmp" ]; then
    local dir
    dir="$(cat "$tmp")"
    rm -f "$tmp"
    if [ -n "$dir" ]; then
      cd "$dir"
    fi
  fi
}

alias ll="lfcd"

alias pr="ll $HOME/Projects"
